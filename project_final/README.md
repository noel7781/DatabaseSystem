 이 프로그램은 마지막 프로젝트로 Log Manager을 통한 리커버리를 구현했다. 로그를 기록하는 경우는 Begin / Commit / Abort / Update 4가지 경우밖에 없으므로 이미 만들어진 데이터베이스 파일을 가지고 리커버리를 진행한다고 생각하고 프로그램을 만들었다.
우선 Update를 제외한 3가지 경우는, 각 key 값에 맞는 value가 없으므로 그 부분을 제외한 부분을 트랜잭션이 해당 part를 호출했을때 로그를 남기게 만들었다. UPDATE를 제외한 로그들은 old image와 new image를 제외한 값을 저장했으며 UPDATE경우에 모든걸 로그에 남기며, Datalength는 최대길이인 120으로 설정했다. 그리고 log를 flush해주는 함수를 만들었는데, log를 flush하는 경우는 buffer page가 eviction됬을경우 또는 commit이 일어나는 2가지 경우이므로 각각 해당되는 경우에 flushLog()함수를 추가했다. logPool은 로그를 저장하는 리스트이며 모든 로그를 남긴후에는 로그풀을 clear시키고 다음로그를 받을 준비를 한다.

 Redo History 방법으로 (Redo Winner방법도 비슷하지만) 리커버리 파트에서 해야되는 3가지 파트로 1.Analyzelog 2.Redo 3.Undo가 있는데, 먼저 analyzeLog()함수는 로그 파일크기만큼 버퍼배열을 만들어서 모두 담아낸다.먼저 이런식으로 다 담아낸 후 로그의 특징에 따라 Update와 아닌것으로 나뉘는데, Update인 경우 길이 전부를 받아낸다.(모든 struct 구조체의 크기를합치면 284) 반대의 경우 필요한것만 받아서 크기가 28이 된다.그렇게 전부 로그를 로그풀에 옮기면서, Redo part에서 하는게 buffer page의 수정으로 Redo를 하는것이기 때문에 Analyze part에서 열어야하는 테이블목록을 추가시켜준다.그리고 int와 Log구조체를 가지는 멀티맵을 하나 정해서 loser 트랜잭션을 가려내는 작업을 했다. Redo history방법을 사용하기 위하여 딱히 winner 트랜잭션은 가지고 있을 필요가 없다고 생각해서 저장하지 않았다. 이 과정을 끝나면 Analyze는 끝나고 Redo part 에서 필요한 테이블을 모두 연다. 그리고 logPool의 log들을 보면서 모든 log를 redo한다. 이렇게 하면 Redo part도 끝이나고, Undo part에서는 loser transaction에 대해서만 수행하는데, loser의 모든 로그를 멀티맵에 담아뒀으므로 begin이 나올때까지 로그를 하나씩 빼면서 undo를 해준다. begin을 만나면 커밋log를 보내서 undo가 끝났음을 표시해줬다. 이렇게 하면 DB가 꺼졌다가 켜졌을때, init_db함수에서 리커버리와 관련된 3개의 함수를 호출하면서 자연스럽게 꺼지기 직전에 commit된 모든 트랜잭션들은 살려내고 uncommited transaction은 모두 진행을 안시킨 상태로 만들어 atomicity와 durability를 update에 관하여 만족하도록 구현을 했다.